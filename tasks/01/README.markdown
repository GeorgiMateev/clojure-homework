# Седем малки функции

<div id="include-mathjax"></div>

Ученето на нов език е най-забавно в началото. За да прихванете това-онова от
езика, искаме от вас да имплементирате 7 малки функции.

## digits

Напишете функция `digits`, която приема число и връща цифрите му (в десетична
бройна система). Цифрите трябва да са подредени в същия ред, в който са в
числото:

    (digits 1024) ; [1 0 2 4]

Ако резултата се подаде на [from-digits][challenge-1], трябва да поучите
оригиналното число.

[challenge-1]: /challenges/1

## prime-factors

Напишете функция `prime-factors`, която приема число и връща последователност
от простите му множители. Множителите трябва да са подредени във възходящ ред
и всеки трябва да се среща толкова пъти, колкото пъти дели числото:

    (prime-factors 6)   ; [2 3]
    (prime-factors 300) ; [2 2 3 5 5]

Изразът `(apply * (prime-factors n))` трябва да се оценява до `n`.

## fizzbuzz

Напешете функция `fizzbuzz` приемаща число _n_ и връщаща последователност
съдържаща числата от 1 до _n_, като:

* Вместо всяко число, което се дели на 3 има `"fizz"`
* Вместо всяко число, което се дели на 5 има `"buzz"`
* Вместо всяко число, което се дели на 3 и на 5 има `"fizzbuzz"`

Например:

    (fizzbuzz 7) ; [1 2 "fizz" 4 "buzz" "fizz" 7]

## densities

Напишете функция `densities`, приемаща последователност и връщаща нова
последователност, в която на мястото на всеки елемент от подадената
последователност се съдържа броя пъти, в което елемента се намира в нея.

Например:

    (densities [:a :a :b :b :c :a]) ; [3 3 2 2 1 3]

## index-by

Напишете функция `index-by`, която приема функция _f_ и последователност _xs_
и връща мап, в който всеки елемент `x` от _xs_ е стойност, към която сочи ключ
`(f x)`. Например:

    (index-by count ["mu" "foo" "larodi"])
    ; {2 "mu", 3 "foo", 6 "larodi"}

Ако два елемента биха имали един ключ, няма значение кой от тях ще изберете за
стойност. В следващия пример и двата резултата са валидни:

    (index-by count ["foo" "bar"])
    ; {3 "foo"}
    ; {3 "bar"}

## harmonic

Напишете функция `harmonic`, която да връща _n_-тото [хармонично
число][harmonic]:

$$ H_n = \sum_{i=1}^{n}\frac{1}{i}
       = 1 + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{n} $$

Например:

    (harmonic 2) ; 3/2
    (harmonic 3) ; 11/6

Функцията е нужно да работи само с положителни числа.

[harmonic]: http://en.wikipedia.org/wiki/Harmonic_number

## uniquify

Напишете функция `uniquify`, която приема последователност от низове _xs_ и
връща нова последователност, в която всяко повторно срещане на низа е
заместено с друг низ. Новия низ се получава с добавяне на тире и броя срещания
до момента. Например:

    (uniquify ["a" "b" "a" "b" "a"]) ; ["a" "b" "a-1" "b-1" "a-2" ]

Приемете, че входните низове не съдържат тирета, т.е., `["a" "a" "a-1"]` не е
валиден вход.

## Бележки

* "Приема последователност" значи "приема **всякаква** последователност".
* "Връща последователност" значи "връща **каквато и да е** последователност".
* Свободни сте да си дефинирате помощни функции, имена и каквото още поискате.
* Употребата на неща извън `clojure.core` е забранена.
* [Clojure cheatsheet][cheatsheet] е ваш приятел.
* **Пуснете си [примерния тест][sampletest]**. Целта му е да провери, че системата ни за
  проверка се справя с вашето решение. Ако има грешка при неговото изпълнение,
  ще има грешка и при проверката, в резултат на което е вероятно да имате 0
  точки.
* За да пуснете [примерния тест][sampletest] , просто добавете файл
  `solution.clj` в директорията на домашното, влезте в нея и изпълнете:
    `$ clj sample_test.clj`
  ...където `clj` е изпълнимото име на Clojure на вашата машина. Обърнете
  внимание, че в текущата директория трябва да има `sample_test.clj` и
  `solution.clj`.
* Дефинирайте всички функции, дори да не можете да решите цялата задача. В
  такъв случай, функцията ви е добре да връща `nil`. Може направо да започнете
  с [нашия шаблон][template].
* Не връщайте константи стойности, с цел да отгатнете с какво тестваме
  решенията ви. Преглеждаме всяко решение – в случай, че отгатнете успешно, ще
  ви вземем голям брой точки за да ви обезсърчим от подобни опити.
* **Придържайте се стриктно към [ръководството за стил][styleguide]!** В бъдещите
  задачи ще отнемаме точки за неспазване на стилистичните норми наложени от
  гореспоменатото ръководство. Ще е напълно в реда на нещата да получите 0 точки
  за напълно работеща задача, поради неспазване на конвенциите. Така че по-добре
  започнете и свикнете от сега ;)

[cheatsheet]: http://clojure.org/cheatsheet
[sampletest]: https://github.com/fmi/clojure-homework/blob/master/tasks/01/sample_test.clj
[template]: http://github.com/fmi/clojure-homework/blob/master/tasks/01/template.clj
[styleguide]: https://github.com/bbatsov/clojure-style-guide
